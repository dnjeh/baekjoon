#include <stdio.h>
int a[1010][1010], b[1010][1010], c[1000010], n, m; //원본(a), 실제 사용(b), 토마토 위치 기록용(c), 조건으로 주어진 n, m
void find(int x, int y, int cnt) { //b의 특정 칸에 도착하면 몇일+1 로 기록하고, 계속 뻗어나가는 함수
    b[y][x]=cnt;
    if(x+1<m&&b[y][x+1]!=-1&&(!b[y][x+1]||b[y][x+1]>cnt+1)) find(x+1, y, cnt+1); //기록될 일수보다 기록된 일수가 크다면
    if(x-1>=0&&b[y][x-1]!=-1&&(!b[y][x-1]||b[y][x-1]>cnt+1)) find(x-1, y, cnt+1); //기록될 일수로 덮어 씌운다
    if(y+1<n&&b[y+1][x]!=-1&&(!b[y+1][x]||b[y+1][x]>cnt+1)) find(x, y+1, cnt+1);
    if(y-1>=0&&b[y-1][x]!=-1&&(!b[y-1][x]||b[y-1][x]>cnt+1)) find(x, y-1, cnt+1);
}
void printa() {                 //오류 검토에 쓸 함수였지만.. 해결할 방도가 떠오르지 않는다
    for(int i=0;i<n;i++) {
        for(int j=0;j<m;j++) {
            printf("%d ", b[i][j]);
        }
        printf("\n");
    }
}
int main() {
    int i, j, max=-1, ind=0; //최대로 걸리는 일수+1(max), 위치 기록용 배열의 인덱스 변수 ind
    scanf("%d %d", &m, &n);
    for(i=0;i<n;i++) for(j=0;j<m;j++) {
        scanf("%d", &a[i][j]);
        if(a[i][j]==-1) b[i][j]=-1; //원본도 비어있다면 실제 사용(b)에도 그리 기록해준다
        else if(a[i][j]) {          //토마토가 들어있는 칸이라면, 
            if(!i&&!j) c[ind++]=-1; //0, 0일땐 곧 없다고 기록되니 -1로 기록해주고
            else c[ind++]=i*10000+j; //아니라면 그 좌표를 살짝 바꿔 기록해준다
        }
    }
    for(i=0;c[i];i++) {
        if(c[i]==-1) find(0, 0, 1); //0, 0 이라면 이리 호출해주고,
        else find(c[i]%10000, c[i]/10000, 1); //아니라면 좌표 그대로 넣어준다.
    } //이렇게 모든 토마토의 예상 시간을 기록 했다고 가정하고,
    for(i=0;i<n;i++) {  //모든 칸을 뒤진다
        for(j=0;j<m;j++) {
            if(!b[i][j]) {
                printf("-1"); //아직도 익지 않았다면 -1를 출력&종료하고,
                return 0;
            }
            else if(b[i][j]!=-1&&(max==-1||b[i][j]>max)) { //해당 칸이 빈 칸이 아니면서, 예상 시간 최고 기록이 갱신되거나 없다면
                max=b[i][j]; //최고 기록으로 기록해준다.
            }
        }
    }
    printf("%d", max-1); //이후 -1을 해줌으로서 일수 출력
}